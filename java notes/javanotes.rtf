{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.16299}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang9 Ubuntu Pastebin\par
Paste from test at Thu, 14 Feb 2019 07:40:23 +0000\par
Java\par
\par
\par
 Pl - Simple way to talk to os shell\par
\par
os shell\par
 10 + 10\par
\par
 HLL -->Assembly---low level bit patterns\par
\par
 HLL-program1--->assembly --->program2--loaded  on os--hardware--will run the code.\par
\par
 program1 -compiler\par
 program2- runtime\par
\par
Green: 1989 - SUN\par
   Objective: Build one software for all os    \par
\par
1989 -1990-->1991-Test faild\par
\par
1991---->Virtual computing---jvm--virtual os   \par
\par
////////////////////////////////////////////\par
JVM --Code?\par
\par
Pl - java Programming language\par
..............................\par
\par
What is java pl?\par
\par
java pl is object oriented,functional  programming language.\par
\par
Programming paradigms:\par
Paradigm means way of solving the problem.\par
\par
The language is just tool which implments the paradigm.\par
\par
Paradigms:\par
1.procedure - c\par
2.oo - c++,java,c#..\par
3.fp - scheme,js,java,groovy,scala..\par
4.Event driven\par
5.Reactive programming\par
......\par
java is now object oriented, functional ,event driven,reactive programming.\par
\par
polyglot : Many programming languages,but runtime is same\par
\par
java,groovy,scala,kotlin,Ruby ----->JVM\par
\par
.............................................\par
\par
Language Design:\par
1.Language fundamentals\par
2.Object oriented programming\par
3.Exception handling\par
4.Collections\par
5.IO\par
\par
////////////////////////////////////////\par
How to start development?\par
Compiler,IDE\par
\par
compiler,runtime => jdk - >java development kit - collection of tools and basic libs to write ,compile,test java programs.\par
\par
jdk is contains\par
1.bin folder\par
2.jre folder\par
3.lib folder\par
\par
compiler  -javac - will convert java source code into byte code(assembly)\par
\par
runtime - java- will run byte on os\par
\par
libs - jre/lib - runtime libs\par
////////////////////////////////////////////\par
\par
java version:\par
java or jdk 1.0\par
java 2\par
java 3\par
java 4\par
java 5 - major improvments\par
java 6\par
java 7\par
java 8 ---stable version jdk 1.8\par
java 9\par
java 10 \par
java 11 - beta current\par
////////////////////////////////////////////\par
\par
Java Applications: editions\par
1.desk top app - JSE -java Standard Edition\par
2.web apps - JEE -java Enterprise\par
3.Device apps - JME - java Micro Edition | java Mobile Edition\par
//////////////////////////////////////////\par
\par
IDE : Eclipse, IntelliJ idea,vs code,notepad,notepad++\par
\par
/////////////////////////////////////////////\par
Eclipse:\par
\par
Workspace: where you are going to store your java projects\par
\par
javaproject layout\par
projectName\par
   src- -souce code\par
   bin  -compiled code\par
\par
Coding standards:\par
\par
1.Source program\par
 FileName.java\par
FileName rules\par
1.FileName must be meaningfull to the problem statement.\par
HelloWorld.java\par
\par
2.compiled Code\par
  FileName.class - Assembly code\par
\par
javac HelloWorld.java\par
\par
 HelloWorld.class\par
\par
java HelloWorld\par
  It will load jvm on os and will load HelloWorld.class.\par
\par
Every pl has entry point to start program execution - main method.\par
\par
c / c++\par
void main()\{\par
\par
\}\par
\par
java main method\par
\par
public static void main(String[]args)\{\par
   //start your app\par
\}\par
\par
main method will load jvm into os,and will load our code on jvm...\par
\par
\par
public class HelloWorld \{\par
\tab public static void main(String[] args) \{\par
        //App starts\par
\tab\tab System.out.println("Hello Java!");\par
\tab\}\par
\}\par
\par
Language fundamentals:\par
1.type system\par
2.variables\par
3.literals\par
4.operators\par
5.control structures\par
6.looping\par
\par
1.type system\par
2.variables\par
3.literals\par
\par
Pl -  to create program--->collection of instructions.\par
Instructions  -  collection of data , how to process the data.\par
\par
Software:\par
 ->Store the data\par
 ->process the stored data\par
 ->Get the Report after processing\par
\par
Store the data:\par
1.Persitant storage - Permanent storage\par
   ->File System-->data base\par
2.Non persistant storage - In memory storage\par
   ->Data is stored in RAM,CPU Registers\par
\par
In java\par
 ->Store the data \par
    ->In memory\par
       ->variables : Data Holder,Stores data\par
     variable type x=10-value(data)-literals\par
     variable type y=10;\par
 ->process the stored data\par
     variable result = x + y;\par
 ->Get the Report after processing\par
     print the result is result -read,write\par
\par
  type variable=value(literal)\par
\par
  type-->numbers-0,1 -core type.\par
\par
  Abstract data types\par
     create new types on core type.\par
\par
  number\par
     -text,nontext\par
\par
  text =characters---string\par
  nontext -number\par
  number\par
    dec,oct,hex,binary\par
   \par
 1\par
 45.89\par
 7777777777777777777777777777777777  \par
 89.9e4\par
 every storage capacity called size\par
 based on value,jvm will request the space  to store the value. \par
\par
 int x=10;--->jvm will request os--->hardware   that i need 2 bytes memory.\par
\par
 number --byte,short,int,long,float,double\par
\par
 10 -- 100100001\par
\par
int 4 bytes -2,147,483,648 to 2,147,483,647.\par
\par
byte 1 byte -128 to 127.\par
\par
byte a =10; //valid\par
byte b =150; error\par
\par
price =90.89 // 4 bytes | 8 bytes\par
\par
BigInteger lightSpeed=934343434343434343434343434343434343434343434343434343434343434343434343443433434343434;\par
\par
java types\par
1.text types \par
  char - single character\par
  String - collection of characters\par
2.Numbers\par
  byte,short,int,long\par
  float,double\par
3.state type : on and off - booleans\par
  true  - 1 bit\par
  false - 0 bit\par
\par
4.Custom types :Create new Types by the programmer based on 1 ,2, 3\par
   Reference types\par
\par
Error types:\par
1.compile time error\par
    compiler verfies your souce code ,test\par
whether any violation.\par
 Type violation.\par
 if the variable is assigned wrong literal  which is not part of that type or its family\par
 will produce compile time error.\par
   ->The compiler will ensure the type of variable should match the value assigned.\par
\par
 byte b =10; //valid\par
 byte b= true; //in valid\par
\par
Strongly Typed | static typing | early binding programming language\par
  The programming language will test the type of variable during compile time phase.\par
\par
  c,c++,java,C# ,groovy....\par
\par
Weakly typed | dynamic typing | late binding programming language\par
  The pl will test the type of variable during\par
 runtime phase\par
 js,groovy,scala,python.....\par
 \par
2.Runtime error\par
\par
    (0)-100\par
       |\par
  byte b  =10 (0,1,1,0)\par
   what is type of b => byte\par
   what is type of 10 => int\par
\par
Note: the variable type is different from value type.\par
 \par
Rules:\par
 byte,short,int,long \par
    value type is by default is int(4 bytes)\par
 byte b  =10(int)\par
    \par
   2 bytes= 4 bytes\par
\par
 type casting: converting from one type to another type.\par
\par
 float,double\par
   default value type is double\par
  float flt =90.78;\par
\par
 char\par
   single character - ''\par
  char storage 16 bit unicode character.\par
   char a=90\par
 booleans\par
   boolean isValid = true;\par
\par
 String : collection of unicode characters\par
///////////////////////////////////////////////////////////////\par
Operators:\par
\par
Arthimetic operators:\par
  +,-,*,/,%\par
  ++,--\par
\par
comments: the information about your code\par
// -single line comment\par
/**\par
\par
**/\par
\par
Operator Overloading:\par
\par
 Changing Meaning of operator\par
\par
 + =>Addition - numbers 10 +10\par
 + =>concatation = string+string or string + variable\par
    "the result is" + result\par
\par
 counter = counter +1 equal to counter+=1\par
\par
///////////////////////////////////////////////////////////////\par
The Equality and Relational Operators\par
.....................................\par
==      equal to\par
!=      not equal to\par
>       greater than\par
>=      greater than or equal to\par
<       less than\par
<=      less than or equal to\par
\par
Operand\par
  int x=1,y=2;\par
  int r = x + y;\par
          |     \par
type result= operand  + operand\par
                      |\par
                  operation\par
\par
Quiz: Explore nummbers with respect to result type\par
\par
     int + int = ?\par
     byte +short = ?\par
     double + int =?\par
\par
==      equal to\par
\par
  Type operand 1 ==  Type operand 2 = boolean\par
\par
Note: equal operator works based on content\par
!= ->operator is opposit to equal to operator\par
\par
/////////////////////////////////////////////////////////\par
-greater than >  \par
-less than <\par
 type result = operand1 >  operand 2 \par
 boolean result = 10 > 2;\par
///////////////////////////////////////////////////////////////\par
The Conditional Operators:\par
\par
&& Conditional-AND\par
|| Conditional-OR\par
!  Not\par
\par
Theses operators works based on truth table\par
\par
  t && t =true\par
  f && f =f\par
  t && f = f\par
  \par
boolean res= operand && operand\par
 \tab\tab  |           |\par
\tab      boolean     boolean\par
//////////////////////////////////////////////////////////////\par
Bitwise Operators: Convert numbers into bit pattern(0,1..)\par
>> <<\par
..............................................................\par
Other operators:\par
 ?:  - tenary operator\par
 new - Object creation operator\par
 instance of ->Type verification operator\par
///////////////////////////////////////////////////////////////\par
Control Structures and Statements:\par
..................................\par
1.decision making\par
 -if\par
   if \par
   if..else\par
   if..elseif\par
   if...else if ..else\par
- switch..case\par
statements\par
break,continue\par
\par
//////////////////////////////////////////////////////////\par
\par
if Syntax:\par
\par
 if(condition) \{\par
   //\par
 \}\par
\par
\{ \}-block -if block\par
\par
condition should be boolean\par
\par
switch case : to avoid nested if..else or if..else if + ==\par
 provide clean coding.\par
\par
switch(input)\{\par
  case condition:\par
     code...\par
  default:\par
    //similar to final else\par
\}  \par
"break" not present if the code is inside function /method\par
 will throw error called "not reachable"\par
\par
break statement stops further code execution,once the condition\par
is evaulated true,will come out from the condition\par
//////////////////////////////////////////////////////////////\par
Looping: Iteration :Repeation:\par
 Repeat the same thing until the condition is met.\par
\par
for,while,do..while\par
\par
for : iterator\par
\par
for(declaration and initalization;condition;incrementordecrement)\par
\par
for eg :  i want to produce 10 numbers\par
   0..10\par
condition - boolean - true | false\par
 loop repet until condition is true.\par
\par
infinite loops:\par
// infinite loop\par
for ( ; ; ) \{\par
    \par
    // your code goes here\par
\}\par
for(int i=0; false;i++\{\}\par
\par
while(true)\{\par
\par
\}\par
\par
do\{\}while(true)\par
//////////////////////////////////////////////////////////\par
\par
How to get Input?\par
->Through Java io- input and output\par
->Through command line args\par
\par
Command line args:\par
..................\par
\par
Passing input to the main method.\par
\par
\par
class Adition\{\par
                         input\par
                            |\par
 public static void main(String[]args)\{\par
\par
    String a = args[0] //10\par
    String b = args[1] //10\par
   \par
\par
 \}\par
\}\par
\par
 >java Addition 10 10 ->commandline input\par
\par
\par
String to number conversion: casting\par
\par
///////////////////////////////////////////////////////////////\par
Object oriented Programming concepts and Implementation:\par
........................................................\par
\par
Object:\par
\par
please get employee information -\par
copy text files from c drive to d drive\par
please shutdown machine-01 at 11pm daily\par
\par
What is object?\par
\par
 ->Real world\par
Chair is object?\par
Account is Object?\par
Customer is Object?\par
\par
God is Object? Yes  |No\par
Heat is Object? \par
Love is Object?\par
Hungry is Object?\par
\par
sleep is object?\par
\par
dance is object?\par
.............................................................\par
 "Any thing could be Object but that should be related to Problem Statement"\par
\par
SDLC\par
1.Req Any - Object oriented Any \par
  - Identify Objects\par
    eg :Account\par
2.Design - converting req into documents\par
  ->database design\par
     -Objects are represented "tables"\par
          -account\par
  ->Program design - object oriented\par
       -Account - java-class-Account -Diagrams - UML\par
\par
3.Development: You translate design into coding\par
  Java\par
   ->Source code representation\par
   ->Runtime code representation\par
\par
Object identification:\par
  ->Capturing Data points\par
\par
In Banking:\par
Customer:X\par
\par
firstName,middleName,lastName\par
Dob,address,mobileno,email,gender\par
nationality,panno,adhno,accounttype\par
nominee,amount,date,debit,onlinebanking,mobilbanking\par
\par
Object characteristics:\par
1.state  -data\par
 id,name,salary,department,noofleaves,...\par
\par
 data can be changed or not changed\par
 name - not changed - constants\par
 salary -changed\par
\par
How to implement state in program?\par
  -variables\par
\par
2.behavior\par
  verbs / actions which changes the state(data)\par
 how to implement behavior in program?\par
 -functions / methods\par
\par
3.identity\par
  It is one the state which is used to identify the object.\par
\par
OOP principles  | concepts:\par
..........................\par
1.Abstraction\par
2.Encapsulation\par
3.Modualrity\par
4.Hierachy\par
5.Typing\par
6.Concurrency\par
7.Persistency.\par
\par
Concept\par
1.Abstraction:\par
   Taking necessary properties(charactertics) from the Object\par
  and drop / leave / hide unncessary things.\par
\par
Implementation:\par
2.Design\par
  Customer in Banking System\par
\par
Customer\par
 id\par
 name\par
 address\par
 mobile\par
 email\par
 account type\par
 account\par
\par
Program:\par
class :\par
  Blueprint of Object\par
  Source code representation of Object(Domain/realworld)\par
  fileName Customer.java\par
  \par
Note: class contains characteristics of object.\par
     state,behavior,identity\par
\par
state && identity:\par
variables\par
  type variableName;\par
\par
\par
Custom types:\par
\par
\par
Stage-1\par
\tab\par
                  0,1 -Numbers\par
\tab\tab     |\par
\tab\tab   Machine\par
\par
\par
Stage-2\par
\par
                  Text\par
\tab          a - 97 - ascii\par
\tab\tab      \par
\tab\tab    |\par
  \tab\tab   0,1 -Numbers\par
\tab\tab     |\par
\tab\tab   Machine\par
\par
\par
\par
\par
\par
Stage-3 -High level programmers - Java\par
\par
\par
  Number\tab                 \tab   Text -char,String  byte,short,long,int,double,float\tab\tab         \tab\tab\tab      \tab             a - 97 - ascii\par
 ------------------------------------------------------------\tab\tab            \par
\tab\tab     |\par
  \tab\tab   0,1 -Numbers\par
\tab\tab     |\par
\tab\tab   Machine\par
\par
Abstract data type theroy:\par
--------------------------\par
You can create new types on core types(byte,short,int,long,float,double,char)\par
\par
How to create new Type? - class\par
  - struct,union - c-language\par
   -c with class =>c++\par
\par
class Customer = \{byte,int,short,long,float,double,char,boolean,other class\}\par
\par
Customer ? = Type Name Which is eq int x;\par
\par
 Customer c; =>c is variable and its type is Customer\par
 int x; =>x is variable and its type is int core type.\par
\par
 new  ->operator allocates memory for class\par
        -Instance | Object - memory represention of class in          ram\par
\par
 Syntax for memory allocation for a  class:\par
\par
  Type Pointervariable = new Class()\par
\par
  Customer cust =    new     Customer();\par
   |         |        |         |\par
 Type     Variable  Operator Constructor call\par
\par
\par
  Hey jvm ask the os allocate memory for a class called Customer, once allocation done, return the memory address to the variable called reference(pointer) variable "cust" and ensure that type is Customer.  - Object Creation / Instance creation /instation.\par
\par
///////////////////////////////////////////////////////////////\par
How to work with state-data?\par
\par
1.initalize data\par
2.process data\par
3.read data\par
\par
1.initalize data - write operation\par
\par
Customer cust =new Customer();\par
\par
object access operator\par
 .\par
cust.state =  literal\par
cust.behavior\par
//////////////////////////////////Ac////////////////////////////\par
\par
behavior : methods / functions:\par
\par
1.change the data\par
\par
Account : withdraw and deposit ---operate on data--balance\par
\par
syntax:\par
  \par
    AccessSpecifer returntype methodName(args) \{ \par
\par
\par
    \}\par
\par
   public double withdraw(double amount)\{\par
 \par
     //logic to update balance  \par
  \}\par
\par
\par
///////////////////////////////////////////////////////////////\par
\par
methods : change state - withdraw\par
\par
////////////////////////////////////////////////////////////\par
\par
state -Data initalization:\par
\par
1.After Object creation : after memory allocation\par
1.1.->Direct initalization: you can access state using reference variable\par
  Account acc = new Account();\par
  acc.accno =1 ;\par
  acc.name ="Test";\par
1.2. ->through methods\par
\par
methods can be classified as follow \par
\par
1.biz methods\par
    biz methods which is used for data process / manipulation \par
eg withdraw\par
\par
2.state initalizer methods\par
   methods which are used for state initalization and reading\par
 only.\par
   these methods are called as "setter" and "getter" methods\par
  setters are otherwise called "mutator"\par
  getters are otherwise called "accessor"\par
\par
General coding standards for methods:\par
.....................................\par
\par
  Either biz method or accessor and mutator\par
\par
1.method name must be meaningfull.\par
2.method name must be verb or verb+noun\par
     withdraw,deposit,sleep,add,substract,save,find,delete...\par
     saveAccount,withdrawMoney,addNumber\par
3.method name must start smaller case\par
  incase method+noun - noun must start uppercase.\par
\par
4.method may return or may return value\par
  method no return - return type must be void\par
    public  void add() \{\par
\tab\tab\par
\tab\}\par
    with return\par
       public  int add() \{\par
\tab\tab return 10;\par
\tab\}\par
\par
Arguments and parameters\par
1.type of parameter and arg type must match\par
2.Exact parameter ,args must match.\par
\par
        public int add(int x,int y) \{\par
\tab\tab return x + y;\par
\tab\}\par
\par
methods: setter and getter methods:\par
\par
Rules:\par
setter:\par
\par
1.setter must have public key word.\par
2.setter must have void return return type.\par
3.setter must start with "set" verb and following set,the state\par
  variable must be presented as Noun.\par
4.setter must take arg,its type must match state variable type.\par
5.setter arg variable Name must match state variableName\par
6.setter method body, must have code to initalize the state \par
  variable.\par
    eg:\par
\tab\tab a=a\par
\par
7.For every state variable , you must have setter method\par
\par
\par
\par
Calculator calc=new Calculator();\par
calc is "reference" variable\par
this is "reference" variable\par
 calc and this both are same ? =>yes\par
   because both will point address of Calcuator Object(memory)\par
\par
calc is called "Explicit" reference variable,we declare.\par
this is called "implicit" reference variable, the jvm declare\par
\par
In java : every object has "this" reference variable, declared,injected into object when object is created.\par
\par
When to use "this" ?\par
1.when you want to avoid ambiguity in setters\par
\par
getters : to read state value\par
\par
1.getters must start "public" keyword\par
2.getters must have return type,the type is the type of state\par
3.getters must start with get,followed by state variable as noun\par
4.getters must not have args\par
5.gettters must return state variable\par
 .For every state variable , you must have getter method\par
\par
/////////////////////////////////////////////////////////////\par
\par
setter and getter standard is called "Java Bean Standard"\par
\par
direct vs setter and getter mode of data initzation:\par
\par
1.As per java bean standard,you must use only setter and getter\par
 pattern only not direct.\par
\par
\par
2.During object creation:\par
........................\par
\par
through constructor :\par
  constructor is also method\par
 \par
constructor:\par
1.constructor is used to initalize the state.\par
2.constructor is special method\par
3.constructor method has some special syntax\par
  3.1.constructor must not have return type\par
  3.2.constructor name must be , the name of the Class\par
  3.3.constructor may take arg or not\par
  3.4.A class can have multiple constructor\par
  3.5.Every class must have one constructor at least\par
\tab if you dont write /provide constructor, the compiler   will provide constructor during compilation time.\par
\par
Circle.java -sc\par
public class Circle \{\par
\par
\}\par
compile\par
Circle.class\par
public class Circle \{\par
    //compiler will insert extra code: default constructor\par
   public Circle()\{\par
\par
   \}\par
\}\par
\par
Circle(); //constructor(method) call - to initalize state during object is being ready.\par
\par
method call\par
acc.withdraw(100) //method call->to manipulate the state after \par
object ready\par
cust.setId(1) //method call ->to initalize state after object ready\par
/////////////////////////////////////////////////////////////\par
\par
Default values for instance variables:\par
if values are not initlized by programmer explicitly,jvm will initalize the values implicitly these values are called as "default values"\par
\par
Default values of in built types:\par
1.byte,short,int,long - 0\par
2.float,double - 0.0\par
3.boolean -false\par
4.char - '\\u0000' -invisible unicode char\par
5.Reference types-String,Customer... ->null\par
\par
\par
eg:\par
Circle.java\par
public class Circle \{\par
\tab //int x, y;\par
\tab float x,y;\par
\par
\tab public float getX() \{\par
\tab\tab return x;\par
\tab\}\par
\par
\tab public void setX(float x) \{\par
\tab\tab this.x = x;\par
\tab\}\par
\par
\tab public float getY() \{\par
\tab\tab return y;\par
\tab\}\par
\par
\tab public void setY(float y) \{\par
\tab\tab this.y = y;\par
\tab\}\par
\par
\}\par
\par
\par
Circle.class\par
public class Circle \{\par
\tab //int x, y;\par
\tab float x,y;\par
\par
         //extra code\par
        public Circle()\{\par
           this.x = 0.0;\par
           this.y =0.0;\par
        \}\par
\par
\tab public float getX() \{\par
\tab\tab return x;\par
\tab\}\par
\par
\tab public void setX(float x) \{\par
\tab\tab this.x = x;\par
\tab\}\par
\par
\tab public float getY() \{\par
\tab\tab return y;\par
\tab\}\par
\par
\tab public void setY(float y) \{\par
\tab\tab this.y = y;\par
\tab\}\par
\par
\}\par
\par
///////////////////////////////////////////////////////\par
\par
Circle.java\par
public class Circle \{\par
\tab //int x, y;\par
\tab float x=1,y=1;\par
\par
\tab public float getX() \{\par
\tab\tab return x;\par
\tab\}\par
\par
\tab public void setX(float x) \{\par
\tab\tab this.x = x;\par
\tab\}\par
\par
\tab public float getY() \{\par
\tab\tab return y;\par
\tab\}\par
\par
\tab public void setY(float y) \{\par
\tab\tab this.y = y;\par
\tab\}\par
\par
\}\par
Circle.class\par
public class Circle \{\par
\tab //int x, y;\par
\tab float x=1,y=1;\par
\par
//extra code\par
        public Circle()\{\par
           this.x = 1.0;\par
           this.y =1.0;\par
        \}\par
\par
\tab public float getX() \{\par
\tab\tab return x;\par
\tab\}\par
\par
\tab public void setX(float x) \{\par
\tab\tab this.x = x;\par
\tab\}\par
\par
\tab public float getY() \{\par
\tab\tab return y;\par
\tab\}\par
\par
\tab public void setY(float y) \{\par
\tab\tab this.y = y;\par
\tab\}\par
\par
\}\par
\par
//////////////////////////////////////////////////////////////\par
\par
Circle.java\par
public class Circle \{\par
\tab // int x, y;\par
\tab float x, y;\par
\par
\tab // Add constructor\par
\tab public Circle() \{\par
\tab\tab this.x = 1;\par
\tab\tab this.y = 1;\par
\tab\}\par
\par
\tab public float getX() \{\par
\tab\tab return x;\par
\tab\}\par
\par
\tab public void setX(float x) \{\par
\tab\tab this.x = x;\par
\tab\}\par
\par
\tab public float getY() \{\par
\tab\tab return y;\par
\tab\}\par
\par
\tab public void setY(float y) \{\par
\tab\tab this.y = y;\par
\tab\}\par
\par
\}\par
Circle.class\par
public class Circle \{\par
\tab // int x, y;\par
\tab float x, y;\par
\par
\tab // Add constructor\par
\tab public Circle() \{\par
\tab\tab this.x = 1;\par
\tab\tab this.y = 1;\par
\tab\}\par
\par
\tab public float getX() \{\par
\tab\tab return x;\par
\tab\}\par
\par
\tab public void setX(float x) \{\par
\tab\tab this.x = x;\par
\tab\}\par
\par
\tab public float getY() \{\par
\tab\tab return y;\par
\tab\}\par
\par
\tab public void setY(float y) \{\par
\tab\tab this.y = y;\par
\tab\}\par
\par
\}\par
///////////////////////////////////////////////////////////\par
\par
Constructor parameter and args: through which you can decide\par
what is the default value of state variable\par
\par
Note: if there is any explicit constructor,the jvm wont insert\par
 default constructor.we need to provide no-arg constructor.\par
///////////////////////////////////////////////////////////////\par
Encapsulation:\par
.............\par
 How to access state,methods,class,constructors etc..\par
 Visibility : Who can access\par
\par
 Program1                Program2\par
\par
 code         <----------          \par
  |\par
variables\par
metods\par
class\par
constructor\par
\par
How to enble encapsulation:\par
  keywords -Access Modifiers\par
\par
public,private,default,proected\par
\par
public: code -class,variables(state),methods,constructors\par
\par
can i use public with class?\par
 Yes!\par
what is public?\par
 public means the class can be accessed by any program , any where in the project.\par
 \par
 public class ClassName\{\par
\par
 \}\par
\par
by any program , any where in the project: ?\par
\par
Modualrity :\par
It is one of the core oo concept.\par
\par
Breaking the large thing into multiple units.\par
\par
Every pl supports modualrity.\par
\par
C,c++ => header files #include order.h,customer.h,billing.h\par
\par
java =>packages\par
  package is collection of java files and collection of sub packages.\par
\par
Types of Modularity:\par
1.logical modularity - code is spilt and linked by runtime through special syntax.\par
  package - keyword\par
  import  - keyword\par
\par
2.Physical modularity  - code is spilt and organized on hard disk.\par
  folders-subfolders \par
\par
\par
Implementaion:\par
\par
Define modualrity:\par
\par
 package  com.tcs.igno.infra.machine\par
  |    \par
 keyword\par
\par
com.tcs.igno.infra.machine\par
org.apache.tools.machine\par
java.lang\par
java.util\par
javax.text\par
\par
com-company\par
org-organization\par
java-it represents core java project\par
\par
tcs-Name of the company\par
igno -name of the project\par
infra -Main module of the project\par
machine-sub module inside infra\par
\par
eg:\par
Customer.java\par
\par
package com.tcs.igno.acc;\par
\par
public class Customer \{\par
\par
\}\par
Folder Structure:\par
 src/com/tcs/igno/acc/Customer.java\par
 bin/com/tcs/igno/acc/Customer.class\par
\par
\par
\par
import - is used to link programs\par
\par
import  logicalpackagestructure\par
imoport com.tcs.igno.acc.Customer;\par
\par
\par
default: package level scopping / within the same folder /package\par
\par
no keyword: consider default scope.\par
\par
Note:\par
1.if the class is declared in default scope, the  other class in the package only can access.\par
2.import statment not neccessary to link classes if it is in the same package-implicit linking\par
  \par
\par
private : the classes can't be declared with private\par
   -No private classes.\par
\par
\par
protected: the classes can't be declared with protected \par
  -No protected classes\par
\par
import rules:\par
1.you can import a particular class\par
2.you can import all classes from one package - *.\par
\par
 coding standard:\par
 1.dont use *.\par
\par
Types of packages:\par
1.in built packages\par
  supplied by jdk,jre\par
 all in built packages starts with java or javax.\par
 in built package name cant be used as custom package\par
\par
java provides lot of packages based on development use case:\par
\par
java.lang\par
   java.lang.System\par
     System - class--jvm\par
Note: the compiler and runtime will import java.lang automatically- default import.\par
String,Object,Class,Short,Byte,Integer,Double,Float....\par
\par
java.util:\par
   Data Structure\par
   Utility classes like Scanner\par
\par
java.sql \par
Data base programming \par
java.io \par
io operations\par
java.net\par
 network programming such as sockets,udp,http\par
java.text\par
  Text processiong\par
etc.................................\par
2.custom packages\par
 packages created by you.\par
 com.tcs.\par
 com.google\par
 com.ibm\par
\par
3.thrid party packages\par
 packages created and distributed by thrid parties\par
\par
 Spring,Hibernate,opensource projects such apache....\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
  \par
Download as text\par
}
 